//............ method 1 using DFS


// #include <bits/stdc++.h>
// #include<unordered_map>
// #include<list>
// #include<vector>
// #include<stack>
// void toposortDFS(int node , vector<bool>&visited , unordered_map<int,list<int>>&adj , stack<int>&s){
//     visited[node] =true;
//     for(auto neighbour : adj[node]){
//         if(!visited[neighbour]){
//             toposortDFS(neighbour, visited , adj , s);
//         }
//     }
//     s.push(node);
// } 
// vector<int> topologicalSort(vector<vector<int>> &edges, int v, int e)  {
//     // Write your code here
//     //create adj list
//     unordered_map<int,list<int>> adj;
//     for(int i = 0 ; i < e ; i++){
//         int u = edges[i][0];
//         int v = edges[i][1];
//         adj[u].push_back(v);
//     }
//     vector<bool>visited(v);
//     stack<int>s;
//     for(int i = 0 ; i < v ; i++){
//         if(!visited[i]){
//             toposortDFS(i , visited , adj , s);
//         }
//     }
//     vector<int>ans;
//     while(!s.empty()){
//         ans.push_back(s.top());
//         s.pop();
//     }
//     return ans;
// }




//......method 2 :- kahn algorithm

#include <bits/stdc++.h>
#include<unordered_map>
#include<list>
#include<vector>
#include<queue> 
vector<int> topologicalSort(vector<vector<int>> &edges, int v, int e)  {
    // Write your code here
    //create adj list
    unordered_map<int,list<int>> adj;
    for(int i = 0 ; i < e ; i++){
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u].push_back(v);
    }
    //find indegree
    vector<int>indegree(v);
    for(auto i : adj){
        for(auto j : i.second){
            indegree[j]++;
        }
    }
    //push into queue with 0 indegree
    queue<int>q;
    for(int i = 0 ; i < v ; i++){
        if(indegree[i] == 0)q.push(i);
    }
    //do bfs and update indegree
    vector<int>ans;
    while(!q.empty()){
        int front = q.front();
        q.pop();
        ans.push_back(front);
        //update indegree
        for(auto neighbour: adj[front]){
            indegree[neighbour]--;
            if(indegree[neighbour] == 0)q.push(neighbour);
        }
    }
    return ans;
}
