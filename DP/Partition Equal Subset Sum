#include <bits/stdc++.h>
using namespace std;

bool solve(int i, int target, vector<int> &arr) {
    if (target == 0) return true;
    if (i == 0) return (arr[0] == target);

    bool notPick = solve(i - 1, target, arr);
    bool pick = false;
    if (arr[i] <= target)
        pick = solve(i - 1, target - arr[i], arr);

    return pick || notPick;
}

class Solution {
  public:
    bool equalPartition(vector<int>& arr) {
        int sum = accumulate(arr.begin(), arr.end(), 0);
        if (sum % 2 != 0) return false;  // Odd sum can't be partitioned

        int target = sum / 2;
        int n = arr.size();
        return solve(n - 1, target, arr);
    }
};










#include <bits/stdc++.h>
using namespace std;

bool solve(int i, int target, vector<int> &arr, vector<vector<int>> &dp) {
    if (target == 0) return true;
    if (i == 0) return (arr[0] == target);

    if (dp[i][target] != -1) return dp[i][target];

    bool notPick = solve(i - 1, target, arr, dp);
    bool pick = false;
    if (arr[i] <= target)
        pick = solve(i - 1, target - arr[i], arr, dp);

    return dp[i][target] = pick || notPick;
}

class Solution {
  public:
    bool equalPartition(vector<int>& arr) {
        int sum = accumulate(arr.begin(), arr.end(), 0);
        if (sum % 2 != 0) return false;

        int target = sum / 2;
        int n = arr.size();

        vector<vector<int>> dp(n, vector<int>(target + 1, -1));
        return solve(n - 1, target, arr, dp);
    }
};









